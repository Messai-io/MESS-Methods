/**
 * Export and Sharing Utilities for MESSAI Platform
 *
 * This module provides utilities for exporting data, generating reports,
 * and creating shareable links for research insights.
 */

import { type ScoredGap } from './gapScoringAlgorithm';

export interface ExportOptions {
  format: 'pdf' | 'csv' | 'json' | 'markdown' | 'bibtex';
  includeMetadata: boolean;
  includeCharts: boolean;
  includeReferences: boolean;
  customTitle?: string;
  customDescription?: string;
}

export interface ShareableLink {
  url: string;
  shortUrl: string;
  expiresAt: Date;
  accessCount: number;
  isPublic: boolean;
}

/**
 * Convert array of objects to CSV format
 */
export function arrayToCSV<T extends Record<string, any>>(data: T[], filename?: string): string {
  if (data.length === 0) return '';

  const headers = Object.keys(data[0] || {});
  const csvContent = [
    headers.join(','),
    ...data.map((row) =>
      headers
        .map((header) => {
          const value = row[header];
          // Escape quotes and wrap in quotes if contains comma or quote
          if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value;
        })
        .join(',')
    ),
  ].join('\n');

  return csvContent;
}

/**
 * Download data as CSV file
 */
export function downloadCSV<T extends Record<string, any>>(data: T[], filename: string): void {
  const csv = arrayToCSV(data);
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', `${filename}.csv`);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/**
 * Download data as JSON file
 */
export function downloadJSON(data: any, filename: string): void {
  const jsonString = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', `${filename}.json`);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/**
 * Generate markdown report for research gaps
 */
export function generateGapMarkdownReport(gaps: ScoredGap[], options: ExportOptions): string {
  const timestamp = new Date().toISOString().split('T')[0];
  const title = options.customTitle || 'Research Gap Analysis Report';
  const description = options.customDescription || 'Generated by MESSAI Gap Scoring Algorithm';

  const report = [
    `# ${title}`,
    ``,
    `**Generated:** ${timestamp}`,
    `**Platform:** MESSAI Research Platform`,
    `**Description:** ${description}`,
    ``,
    `## Executive Summary`,
    ``,
    `This report analyzes ${gaps.length} research gaps in microbial electrochemical systems (MES) using AI-powered prioritization algorithms.`,
    ``,
    `### Key Findings`,
    `- **Critical Priority Gaps:** ${gaps.filter((g) => g.urgencyLevel === 'critical').length}`,
    `- **High Priority Gaps:** ${gaps.filter((g) => g.urgencyLevel === 'high').length}`,
    `- **Average Score:** ${(gaps.reduce((sum, g) => sum + g.totalScore, 0) / gaps.length).toFixed(
      1
    )}/100`,
    `- **Top Priority:** ${gaps[0]?.topic || 'None'}`,
    ``,
    `## Detailed Analysis`,
    ``,
    ...gaps
      .map((gap, index) => [
        `### ${index + 1}. ${gap.topic}`,
        ``,
        `**Priority Rank:** #${gap.priorityRank}`,
        `**Overall Score:** ${gap.totalScore.toFixed(1)}/100`,
        `**Urgency Level:** ${gap.urgencyLevel.toUpperCase()}`,
        ``,
        `#### Score Breakdown`,
        `- **Urgency:** ${gap.urgencyScore.toFixed(1)}/100`,
        `  - Scarcity: ${gap.scoreBreakdown.urgency.scarcity.toFixed(1)}`,
        `  - Recency: ${gap.scoreBreakdown.urgency.recency.toFixed(1)}`,
        `  - Contradictions: ${gap.scoreBreakdown.urgency.contradictions.toFixed(1)}`,
        `- **Impact:** ${gap.impactScore.toFixed(1)}/100`,
        `  - Scientific: ${gap.scoreBreakdown.impact.scientific.toFixed(1)}`,
        `  - Commercial: ${gap.scoreBreakdown.impact.commercial.toFixed(1)}`,
        `  - Field-wide: ${gap.scoreBreakdown.impact.field.toFixed(1)}`,
        `- **Feasibility:** ${gap.feasibilityScore.toFixed(1)}/100`,
        `  - Technical: ${gap.scoreBreakdown.feasibility.technical.toFixed(1)}`,
        `  - Resources: ${gap.scoreBreakdown.feasibility.resources.toFixed(1)}`,
        `  - Expertise: ${gap.scoreBreakdown.feasibility.expertise.toFixed(1)}`,
        ``,
        `#### Key Insights`,
        ...gap.reasoning.map((reason) => `- ${reason}`),
        ``,
        `---`,
        ``,
      ])
      .flat(),
    `## Methodology`,
    ``,
    `This analysis uses the MESSAI Gap Scoring Algorithm, which evaluates research gaps based on:`,
    ``,
    `1. **Urgency Factors (40% weight)**`,
    `   - Scarcity of existing research`,
    `   - Recency of last publication`,
    `   - Number of contradictions in literature`,
    ``,
    `2. **Impact Potential (40% weight)**`,
    `   - Scientific breakthrough potential`,
    `   - Commercial viability`,
    `   - Field-wide impact`,
    ``,
    `3. **Feasibility Assessment (20% weight)**`,
    `   - Technical difficulty`,
    `   - Resource requirements`,
    `   - Expertise availability`,
    ``,
    `## Recommendations`,
    ``,
    `Based on this analysis, we recommend:`,
    ``,
    `1. **Immediate Action** on critical priority gaps`,
    `2. **Resource Allocation** to high-impact, high-feasibility opportunities`,
    `3. **Collaborative Approaches** for complex, multi-disciplinary gaps`,
    `4. **Funding Applications** targeting identified opportunities`,
    ``,
    `---`,
    ``,
    `*Report generated by MESSAI Research Platform*`,
    `*Generated by MESS-Methods - Open Source MES Research Tools*`,
  ];

  return report.join('\n');
}

/**
 * Generate BibTeX citations for papers
 */
export function generateBibTeX(papers: any[]): string {
  return papers
    .map((paper) => {
      const year = paper.year || new Date(paper.publicationDate || Date.now()).getFullYear();
      const authors = Array.isArray(paper.authors)
        ? paper.authors.join(' and ')
        : paper.authors || 'Unknown';

      return [
        `@article{${paper.id || 'unknown'},`,
        `  title={${paper.title || 'Unknown Title'}},`,
        `  author={${authors}},`,
        `  year={${year}},`,
        `  journal={${paper.journal || 'Unknown Journal'}},`,
        paper.doi ? `  doi={${paper.doi}},` : '',
        paper.volume ? `  volume={${paper.volume}},` : '',
        paper.pages ? `  pages={${paper.pages}},` : '',
        `  note={Retrieved from MESSAI Research Platform}`,
        `}`,
      ]
        .filter((line) => line)
        .join('\n');
    })
    .join('\n\n');
}

/**
 * Create shareable link for data/analysis
 */
export async function createShareableLink(
  data: any,
  type: 'gaps' | 'contradictions' | 'opportunities' | 'methodology',
  options: {
    isPublic?: boolean;
    expiresInDays?: number;
    title?: string;
    description?: string;
  } = {}
): Promise<ShareableLink> {
  // In a real implementation, this would call an API to store the data
  // and generate a shareable link. For now, we'll simulate it.

  const shareId = generateShareId();
  const baseUrl = typeof window !== 'undefined' ? window.location.origin : 'https://github.com/Messai-io/MESS-Methods';
  const url = `${baseUrl}/share/${type}/${shareId}`;
  const shortUrl = `${baseUrl}/s/${shareId.substring(0, 8)}`;

  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + (options.expiresInDays || 7));

  // Simulate API call
  const shareableLink: ShareableLink = {
    url,
    shortUrl,
    expiresAt,
    accessCount: 0,
    isPublic: options.isPublic || false,
  };

  // Store in localStorage for demo purposes
  if (typeof window !== 'undefined') {
    const shareData = {
      id: shareId,
      type,
      data,
      options,
      createdAt: new Date().toISOString(),
      ...shareableLink,
    };

    localStorage.setItem(`messai_share_${shareId}`, JSON.stringify(shareData));
  }

  return shareableLink;
}

/**
 * Generate unique share ID
 */
function generateShareId(): string {
  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
}

/**
 * Copy text to clipboard
 */
export async function copyToClipboard(text: string): Promise<boolean> {
  try {
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return true;
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      const result = document.execCommand('copy');
      document.body.removeChild(textArea);
      return result;
    }
  } catch (err) {
    console.error('Failed to copy text: ', err);
    return false;
  }
}

/**
 * Download markdown report
 */
export function downloadMarkdown(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/markdown;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);

  link.setAttribute('href', url);
  link.setAttribute('download', `${filename}.md`);
  link.style.visibility = 'hidden';

  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/**
 * Export contradictions data
 */
export function exportContradictionsData(
  contradictions: any[],
  format: 'csv' | 'json' | 'markdown'
): void {
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = `messai-contradictions-${timestamp}`;

  switch (format) {
    case 'csv':
      const csvData = contradictions.map((c) => ({
        topic: c.topic,
        description: c.description,
        severity: c.severity,
        impactScore: c.impactScore,
        paper1Title: c.papers.paper1.title,
        paper1Authors: Array.isArray(c.papers.paper1.authors)
          ? c.papers.paper1.authors.join('; ')
          : c.papers.paper1.authors,
        paper1Year: c.papers.paper1.year,
        paper1Position: c.papers.paper1.position,
        paper2Title: c.papers.paper2.title,
        paper2Authors: Array.isArray(c.papers.paper2.authors)
          ? c.papers.paper2.authors.join('; ')
          : c.papers.paper2.authors,
        paper2Year: c.papers.paper2.year,
        paper2Position: c.papers.paper2.position,
        resolutionStatus: c.resolutionStatus,
      }));
      downloadCSV(csvData, filename);
      break;

    case 'json':
      downloadJSON(contradictions, filename);
      break;

    case 'markdown':
      const markdownContent = generateContradictionsMarkdown(contradictions);
      downloadMarkdown(markdownContent, filename);
      break;
  }
}

/**
 * Generate markdown report for contradictions
 */
function generateContradictionsMarkdown(contradictions: any[]): string {
  const timestamp = new Date().toISOString().split('T')[0];

  const report = [
    `# Research Contradictions Analysis`,
    ``,
    `**Generated:** ${timestamp}`,
    `**Platform:** MESSAI Research Platform`,
    `**Total Contradictions:** ${contradictions.length}`,
    ``,
    `## Summary`,
    ``,
    `- **Critical Severity:** ${contradictions.filter((c) => c.severity === 'critical').length}`,
    `- **High Severity:** ${contradictions.filter((c) => c.severity === 'high').length}`,
    `- **Medium Severity:** ${contradictions.filter((c) => c.severity === 'medium').length}`,
    `- **Low Severity:** ${contradictions.filter((c) => c.severity === 'low').length}`,
    ``,
    `## Detailed Analysis`,
    ``,
    ...contradictions
      .map((contradiction, index) => [
        `### ${index + 1}. ${contradiction.topic}`,
        ``,
        `**Severity:** ${contradiction.severity.toUpperCase()}`,
        `**Impact Score:** ${contradiction.impactScore}/100`,
        `**Status:** ${contradiction.resolutionStatus}`,
        ``,
        `**Description:** ${contradiction.description}`,
        ``,
        `#### Conflicting Positions`,
        ``,
        `**Position A:**`,
        `- Paper: ${contradiction.papers.paper1.title}`,
        `- Authors: ${
          Array.isArray(contradiction.papers.paper1.authors)
            ? contradiction.papers.paper1.authors.join(', ')
            : contradiction.papers.paper1.authors
        }`,
        `- Year: ${contradiction.papers.paper1.year}`,
        `- Position: ${contradiction.papers.paper1.position}`,
        `- Confidence: ${contradiction.papers.paper1.confidence}%`,
        ``,
        `**Position B:**`,
        `- Paper: ${contradiction.papers.paper2.title}`,
        `- Authors: ${
          Array.isArray(contradiction.papers.paper2.authors)
            ? contradiction.papers.paper2.authors.join(', ')
            : contradiction.papers.paper2.authors
        }`,
        `- Year: ${contradiction.papers.paper2.year}`,
        `- Position: ${contradiction.papers.paper2.position}`,
        `- Confidence: ${contradiction.papers.paper2.confidence}%`,
        ``,
        `---`,
        ``,
      ])
      .flat(),
    `## Methodology`,
    ``,
    `Contradictions were identified using MESSAI's AI analysis of ${contradictions.length} research papers, `,
    `looking for conflicting claims, methodological differences, and divergent results.`,
    ``,
    `---`,
    ``,
    `*Report generated by MESSAI Research Platform*`,
  ];

  return report.join('\n');
}

/**
 * Generate parameter sweep export data
 */
export function exportParameterSweepData(sweepData: any, format: 'csv' | 'json'): void {
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = `messai-parameter-sweep-${timestamp}`;

  if (format === 'csv') {
    // Flatten the sweep data for CSV export
    const csvData =
      sweepData.results?.map((result: any, index: number) => ({
        configurationIndex: index + 1,
        powerDensity: result.powerDensity,
        efficiency: result.efficiency,
        cost: result.cost,
        sustainability: result.sustainability,
        overallScore: result.overallScore,
        ...sweepData.parameters,
      })) || [];

    downloadCSV(csvData, filename);
  } else {
    downloadJSON(sweepData, filename);
  }
}

/**
 * Export methodology protocol
 */
export function exportMethodologyProtocol(methodology: any, format: 'markdown' | 'json'): void {
  const timestamp = new Date().toISOString().split('T')[0];
  const filename = `messai-methodology-${methodology.name
    ?.replace(/\s+/g, '-')
    .toLowerCase()}-${timestamp}`;

  if (format === 'markdown') {
    const markdownContent = [
      `# ${methodology.name}`,
      ``,
      `**Type:** ${methodology.type}`,
      `**Duration:** ${methodology.duration}`,
      `**Cost:** ${methodology.cost}`,
      `**Difficulty:** ${methodology.difficulty}`,
      `**Success Rate:** ${methodology.successRate}%`,
      ``,
      `## Description`,
      ``,
      methodology.description,
      ``,
      `## Required Equipment`,
      ``,
      ...(methodology.requiredEquipment?.map((eq: string) => `- ${eq}`) || []),
      ``,
      `## Methodology Steps`,
      ``,
      ...(methodology.steps
        ?.map((step: any) => [
          `### Step ${step.step}: ${step.title}`,
          ``,
          `**Duration:** ${step.duration}`,
          `**Resources:** ${step.resources?.join(', ')}`,
          ``,
          step.description,
          ``,
          `**Critical Points:**`,
          ...(step.criticalPoints?.map((point: string) => `- ${point}`) || []),
          ``,
          `**Expected Results:** ${step.expectedResults}`,
          ``,
        ])
        .flat() || []),
      `## Validation Criteria`,
      ``,
      ...(methodology.validation?.map((criterion: string) => `- ${criterion}`) || []),
      ``,
      `## Expected Outcomes`,
      ``,
      ...(methodology.expectedOutcomes?.map((outcome: string) => `- ${outcome}`) || []),
      ``,
      `---`,
      ``,
      `*Protocol generated by MESSAI Research Platform*`,
    ];

    downloadMarkdown(markdownContent.join('\n'), filename);
  } else {
    downloadJSON(methodology, filename);
  }
}
